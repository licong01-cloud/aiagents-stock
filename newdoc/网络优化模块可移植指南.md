# 网络优化模块可移植指南（可直接复制）

版本: v1.0  
适用: 任意 Python 项目需要“稳定访问外部数据 + 代理池管理 + 自动重试”的场景（如 Akshare/第三方HTTP接口）

---

## 1. 目标与能力

- 统一管理“直连/静态代理/动态代理”并按优先级轮换
- 数据访问期自动：失败重试、指数退避、按错误类型决定是否重试
- 快速可移植：提供一份“轻量实现代码（NetworkOptimizerLite）”可直接复制
- 配置可落地：`proxy_config.json` 结构清晰，支持动态代理 API

典型用途：
- Akshare 某些接口在国内网络不稳定 → 启用代理与重试
- 调用第三方 HTTP API（基金/新闻/情绪/ETF数据） → 降低失败率

---

## 2. 快速集成步骤

1) 复制本指南中的“轻量实现代码”到你的项目（建议保存为 `network_optimizer_lite.py`）
2) 在项目根目录创建或调整 `proxy_config.json`（示例见下文）
3) 在发起 HTTP 请求前，用 `NetworkOptimizerLite` 包装请求，或设置临时代理环境变量
4) 若使用 Akshare，可在调用前通过上下文设置 `HTTP_PROXY/HTTPS_PROXY`

---

## 3. 配置文件 `proxy_config.json`

最小可用示例（直连 + 本地代理，可随时切换）：

```json
{
  "use_proxy": false,
  "proxy_priority": [
    {
      "name": "直连",
      "proxy": null,
      "enabled": true,
      "priority": 1,
      "description": "不使用代理"
    },
    {
      "name": "本地Clash",
      "proxy": "http://127.0.0.1:7890",
      "enabled": true,
      "priority": 2,
      "description": "本地代理"
    }
  ]
}
```

带动态代理示例：

```json
{
  "use_proxy": true,
  "proxy_priority": [
    { "name": "直连", "proxy": null, "enabled": true, "priority": 1 },
    { "name": "本地Clash", "proxy": "http://127.0.0.1:7890", "enabled": true, "priority": 2 },
    {
      "name": "动态IP",
      "type": "dynamic",
      "api_url": "http://api.proxy.com/get?token=xxxx",
      "enabled": true,
      "priority": 3,
      "description": "从API拉取临时代理"
    }
  ]
}
```

字段说明：
- `use_proxy`: 全局是否启用代理
- `proxy_priority`: 代理项数组（按 `priority` 升序尝试）
  - 静态：`{"proxy": "http://host:port"}`
  - 动态：`{"type": "dynamic", "api_url": "..."}`（调用时实时获取）

### 3.1 当前项目代理池配置（敏感信息，内部使用）

以下为本仓库现有的三套动态代理池配置，已用于网络优化模块，请谨慎保管：

```json
{
  "use_proxy": true,
  "proxy_priority": [
    {
      "name": "直连模式",
      "type": "direct",
      "proxy": null,
      "enabled": true,
      "priority": 1,
      "description": "不使用代理，直接连接"
    },
    {
      "name": "神龙IP动态代理",
      "type": "dynamic",
      "api_url": "http://api.shenlongip.com/ip?key=oegww2io&protocol=1&mr=1&pattern=txt&count=1&sign=f5e5d0becf9af3159c1a49faad1e9e91",
      "username": null,
      "password": null,
      "api_key": "",
      "enabled": false,
      "priority": 2,
      "description": "神龙IP动态代理服务（API密钥可能过期，可在代理池配置中手动启用测试）"
    },
    {
      "name": "基流动态代理",
      "type": "dynamic",
      "api_url": "https://api.jiliuip.com/getdip/?app_id=oyy4fnnqyxqku2w8kzj2&num=1&app_secret=3b0v1qighmr11f13ny3d119fc9ctkt4i&pt=1&sep=1",
      "username": "jd3300844792",
      "password": "ife44pxm",
      "api_key": null,
      "enabled": true,
      "priority": 3,
      "description": "基流IP动态代理服务"
    },
    {
      "name": "四叶天动态IP代理",
      "type": "dynamic",
      "api_url": "http://proxy.siyetian.com/apis_get2.html?token=AOwUGbn5WYoNWLNpWV51kaJdXTqVFeNRUS61kerlXTn1STqFUeORVR31kaNpnTEVUMNRVT39EVjBjTEVVM.wNykDMwITM2cTM&limit=1&type=0&time=&split=1&split_text=",
      "username": "changle08",
      "password": "lc78080808",
      "api_key": null,
      "enabled": true,
      "priority": 4,
      "description": "四叶天动态IP代理服务"
    }
  ]
}
```

补充说明：

- 三个动态代理池分别为：神龙IP、基流IP、四叶天；其中神龙IP在默认配置中关闭（enabled=false），基流与四叶天开启。
- username/password 字段如上所示，供需要鉴权的供应商调用；神龙IP当前以 API 参数鉴权，未配置用户名密码。
- 若需要临时切换优先级，可调整 `priority` 数字（越小越优先）。
- 如在公共环境提交代码，建议将本节配置迁移到私密仓库或通过环境变量/CI Secret 注入，避免泄露。

---

## 4. 轻量实现代码（可直接复制）

将以下代码保存为 `network_optimizer_lite.py`，无需其他依赖（仅 requests/urllib3）。

```python
import os
import json
import time
import random
from typing import Any, Dict, List, Optional

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry


class NetworkOptimizerLite:
    """
    轻量可移植网络优化器：
    - 按优先级在 直连/静态/动态 代理间切换
    - 失败自动重试（指数退避）
    - 可返回 requests.Session 或直接发起 GET/POST
    """

    def __init__(self, config_path: str = "proxy_config.json") -> None:
        self.config_path = config_path
        self.config = self._load_config()
        self.use_proxy: bool = bool(self.config.get("use_proxy", False))
        # 仅保存启用的代理，按 priority 排序
        self.proxy_items: List[Dict[str, Any]] = sorted(
            [p for p in self.config.get("proxy_priority", []) if p.get("enabled", True)],
            key=lambda x: x.get("priority", 999)
        )
        self.current_index: int = 0
        self.session = self._build_session()

    # ----------------------
    # 配置 & 会话
    # ----------------------
    def _load_config(self) -> Dict[str, Any]:
        if os.path.exists(self.config_path):
            try:
                with open(self.config_path, "r", encoding="utf-8") as f:
                    return json.load(f)
            except Exception:
                pass
        return {"use_proxy": False, "proxy_priority": [{"name": "直连", "proxy": None, "enabled": True, "priority": 1}]}

    def _build_session(self) -> requests.Session:
        s = requests.Session()
        retry = Retry(
            total=0,  # 由我们手动控制重试
            connect=0,
            read=0,
            backoff_factor=0,
            status_forcelist=[500, 502, 503, 504],
        )
        adapter = HTTPAdapter(max_retries=retry)
        s.mount("http://", adapter)
        s.mount("https://", adapter)
        return s

    def set_proxy_enabled(self, enabled: bool) -> None:
        self.use_proxy = bool(enabled)

    def get_network_status(self) -> Dict[str, Any]:
        current = self._current_proxy_item()
        return {
            "use_proxy": self.use_proxy,
            "proxy_pool_size": len(self.proxy_items),
            "current_proxy": None if not current else current.get("proxy") or current.get("type"),
            "current_name": None if not current else current.get("name"),
        }

    # ----------------------
    # 代理选择与动态拉取
    # ----------------------
    def _current_proxy_item(self) -> Optional[Dict[str, Any]]:
        if not self.proxy_items:
            return None
        self.current_index %= len(self.proxy_items)
        return self.proxy_items[self.current_index]

    def _switch_next_proxy(self) -> None:
        if not self.proxy_items:
            return
        self.current_index = (self.current_index + 1) % len(self.proxy_items)

    def _build_proxies(self, proxy_url: Optional[str]) -> Optional[Dict[str, str]]:
        if not proxy_url:
            return None
        return {"http": proxy_url, "https": proxy_url}

    def _get_proxy_for_request(self) -> Optional[Dict[str, str]]:
        if not self.use_proxy:
            return None
        item = self._current_proxy_item()
        if not item:
            return None
        # 动态代理：实时拉取
        if item.get("type") == "dynamic":
            proxy_url = self.get_dynamic_proxy(item.get("api_url"))
            return self._build_proxies(proxy_url)
        # 静态/直连
        return self._build_proxies(item.get("proxy"))

    def get_dynamic_proxy(self, api_url: Optional[str]) -> Optional[str]:
        if not api_url:
            return None
        try:
            resp = self.session.get(api_url, timeout=8)
            resp.raise_for_status()
            data = resp.json() if "application/json" in resp.headers.get("Content-Type", "") else resp.text
            # 尝试多种常见返回格式解析
            if isinstance(data, dict):
                # 常见键: proxy/ip/host/port/url
                if "proxy" in data:
                    return data["proxy"]
                host = data.get("host") or data.get("ip")
                port = data.get("port")
                if host and port:
                    return f"http://{host}:{port}"
                url = data.get("url")
                if url:
                    return url
            elif isinstance(data, str):
                # 可能是 "host:port" 或 完整URL
                text = data.strip().splitlines()[0].strip()
                if text.startswith("http://") or text.startswith("https://"):
                    return text
                if ":" in text:
                    return f"http://{text}"
        except Exception:
            return None
        return None

    # ----------------------
    # 请求与重试（GET/POST）
    # ----------------------
    def get(self, url: str, *, headers: Optional[Dict[str, str]] = None, timeout: int = 10,
            max_retries: int = 3, backoff_base: float = 1.5, use_proxy: Optional[bool] = None,
            allow_status=(200,)) -> requests.Response:
        return self._request("GET", url, headers=headers, data=None, json_data=None, timeout=timeout,
                             max_retries=max_retries, backoff_base=backoff_base, use_proxy=use_proxy,
                             allow_status=allow_status)

    def post(self, url: str, *, headers: Optional[Dict[str, str]] = None, data: Optional[Any] = None,
             json_data: Optional[Any] = None, timeout: int = 10, max_retries: int = 3, backoff_base: float = 1.5,
             use_proxy: Optional[bool] = None, allow_status=(200,)) -> requests.Response:
        return self._request("POST", url, headers=headers, data=data, json_data=json_data, timeout=timeout,
                             max_retries=max_retries, backoff_base=backoff_base, use_proxy=use_proxy,
                             allow_status=allow_status)

    def _request(self, method: str, url: str, *, headers: Optional[Dict[str, str]], data: Optional[Any],
                 json_data: Optional[Any], timeout: int, max_retries: int, backoff_base: float,
                 use_proxy: Optional[bool], allow_status: tuple) -> requests.Response:
        attempt = 0
        use_proxy_flag = self.use_proxy if use_proxy is None else bool(use_proxy)
        last_exc: Optional[Exception] = None

        while attempt <= max_retries:
            proxies = self._get_proxy_for_request() if use_proxy_flag else None
            try:
                if method == "GET":
                    resp = self.session.get(url, headers=headers, timeout=timeout, proxies=proxies)
                else:
                    resp = self.session.post(url, headers=headers, data=data, json=json_data, timeout=timeout, proxies=proxies)
                # 状态码判断：5xx重试，4xx不重试
                if resp.status_code in allow_status:
                    return resp
                if 500 <= resp.status_code < 600:
                    raise requests.HTTPError(f"Server error: {resp.status_code}")
                # 其它情况（如4xx）直接返回，交给上层处理
                return resp
            except (requests.Timeout, requests.ConnectionError, requests.HTTPError) as e:
                last_exc = e
                attempt += 1
                if attempt > max_retries:
                    break
                # 切换下一个代理 + 指数退避
                self._switch_next_proxy()
                delay = (backoff_base ** attempt) + random.uniform(0, 0.5)
                time.sleep(delay)
            except Exception as e:
                # 不可恢复错误，直接抛出
                raise e

        # 最终失败
        if last_exc:
            raise last_exc
        raise RuntimeError("Request failed without specific exception")


# 可选：在 Akshare/第三方库调用前，暂时性设置环境代理
class ProxyEnv:
    def __init__(self, proxy_url: Optional[str]):
        self.proxy_url = proxy_url
        self._orig_http = os.environ.get("HTTP_PROXY")
        self._orig_https = os.environ.get("HTTPS_PROXY")

    def __enter__(self):
        if self.proxy_url:
            os.environ["HTTP_PROXY"] = self.proxy_url
            os.environ["HTTPS_PROXY"] = self.proxy_url
        return self

    def __exit__(self, exc_type, exc, tb):
        if self._orig_http is not None:
            os.environ["HTTP_PROXY"] = self._orig_http
        else:
            os.environ.pop("HTTP_PROXY", None)
        if self._orig_https is not None:
            os.environ["HTTPS_PROXY"] = self._orig_https
        else:
            os.environ.pop("HTTPS_PROXY", None)
```

---

## 5. 在数据访问中的使用示例

### 5.1 直接用 GET/POST 封装第三方接口

```python
from network_optimizer_lite import NetworkOptimizerLite

opt = NetworkOptimizerLite()
opt.set_proxy_enabled(True)  # 根据需要打开/关闭

# GET 示例
resp = opt.get("https://httpbin.org/ip", max_retries=3)
print(resp.status_code, resp.text)

# POST 示例
resp = opt.post("https://httpbin.org/post", json_data={"q": "test"}, max_retries=3)
print(resp.status_code)
```

### 5.2 与 Akshare 配合（通过临时环境代理）

```python
import akshare as ak
from network_optimizer_lite import NetworkOptimizerLite, ProxyEnv

opt = NetworkOptimizerLite()
opt.set_proxy_enabled(True)

# 获取当前要用的代理URL（若是直连则为 None）
proxy_item = opt._current_proxy_item()
proxy_url = proxy_item.get("proxy") if proxy_item else None

with ProxyEnv(proxy_url):
    # 你的 akshare 调用
    df = ak.stock_zh_index_daily(symbol="sh000001")
    print(df.tail())
```

说明：部分 akshare 内部使用 requests，但不暴露 proxies 参数；通过设置环境变量可全局生效。

---

## 6. 动态代理池管理

场景：你的动态代理提供商给出一个 HTTP API，每次请求返回一个可用代理。

使用方式：

```python
opt = NetworkOptimizerLite()
opt.set_proxy_enabled(True)

# 在 proxy_config.json 中配置了 {"type": "dynamic", "api_url": "http://api.proxy.com/get?token=xxxx"}
# 发起请求时会自动调用 get_dynamic_proxy() 获取最新代理并使用
resp = opt.get("https://httpbin.org/ip", max_retries=3)
print(resp.text)
```

手动拉取与测试：

```python
proxy_url = opt.get_dynamic_proxy("http://api.proxy.com/get?token=xxxx")
print("动态代理:", proxy_url)

# 临时用这个代理发一次请求
if proxy_url:
    r = opt.session.get("https://httpbin.org/ip", proxies={"http": proxy_url, "https": proxy_url}, timeout=8)
    print(r.text)
```

---

## 7. 重试与错误策略（内置规则）

- 会重试：`Timeout`、`ConnectionError`、HTTP `5xx`（服务端错误）
- 不重试：HTTP `4xx`（参数/权限问题）、JSON解析错误等“逻辑错误”
- 退避策略：`delay = backoff_base ** attempt + jitter`（默认 base=1.5）
- 每次重试自动轮换到下一个代理（包含直连项）

---

## 8. 故障排查

1) 所有请求都失败：
- 检查 `use_proxy` 是否开启但代理无效；或先关闭代理改用直连
- 检查动态代理 API 是否返回了可解析的数据结构

2) 动态代理解析失败：
- 打印 `resp.text` 确认返回格式；根据供应商文档调整解析逻辑

3) Akshare 仍然失败：
- 使用 `ProxyEnv` 包裹调用；或在系统层面设置代理；或升级网络环境

---

## 9. 迁移清单（Checklist）

- [ ] 复制 `network_optimizer_lite.py`
- [ ] 在项目根目录放置 `proxy_config.json`
- [ ] 在关键 HTTP 请求处使用 `opt.get/opt.post` 或 `ProxyEnv`
- [ ] 确认超时时间与重试次数满足你的场景
- [ ] 若使用动态代理，填好 `api_url` 并测试解析

---

## 10. 备注与扩展

- 若需要更复杂的功能（批量代理健康检查、批量导入TXT、代理优先级动态调整、请求统计面板等），可在此基础上扩展
- 与现有项目的 `NetworkOptimizer` 设计保持思想一致：优先级、降级、重试、可观测

---

附：最简使用示例

```python
from network_optimizer_lite import NetworkOptimizerLite

opt = NetworkOptimizerLite()
opt.set_proxy_enabled(True)
print(opt.get_network_status())

resp = opt.get("https://httpbin.org/ip", max_retries=3)
print(resp.text)
```


