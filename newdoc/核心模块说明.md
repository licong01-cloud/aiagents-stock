# 核心模块技术说明文档

**版本**: v1.0  
**创建日期**: 2025-11-01  
**文档类型**: 技术参考文档  
**适用范围**: 复合多AI智能体股票团队分析系统

---

## 文档目录

1. [概述](#1-概述)
2. [统一数据获取模块 (DataSourceManager)](#2-统一数据获取模块-datasourcemanager)
3. [网络优化模块 (NetworkOptimizer)](#3-网络优化模块-networkoptimizer)
4. [AI 分析师模块 (StockAnalysisAgents)](#4-ai-分析师模块-stockanalysisagents)
5. [持仓管理模块](#5-持仓管理模块)
6. [集成调用示例](#6-集成调用示例)
7. [附录](#7-附录)

---

## 1. 概述

### 1.1 系统架构总览

本系统是一个基于 DeepSeek AI 的股票分析平台，采用模块化设计，包含以下核心模块：

```
┌─────────────────────────────────────────────────────────────┐
│                      应用层 (app.py)                         │
│              Streamlit Web 界面 + 用户交互                   │
└─────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
        ▼                     ▼                     ▼
┌───────────────┐    ┌───────────────┐    ┌───────────────┐
│  持仓管理模块  │    │ AI分析师模块  │    │  其他功能模块  │
│  Portfolio    │    │ StockAnalysis │    │  (龙虎榜/板块) │
│  Manager      │    │  Agents       │    │               │
└───────────────┘    └───────────────┘    └───────────────┘
        │                     │                     │
        └─────────────────────┼─────────────────────┘
                              │
                ┌─────────────┴─────────────┐
                │                           │
                ▼                           ▼
        ┌───────────────┐          ┌───────────────┐
        │  数据获取模块  │          │  网络优化模块  │
        │  DataSource   │◄─────────│  Network      │
        │  Manager      │          │  Optimizer    │
        └───────────────┘          └───────────────┘
                │                           │
                ▼                           ▼
        ┌───────────────────────────────────────┐
        │  外部数据源                            │
        │  - Tushare (直连，优先)               │
        │  - Akshare (通过网络优化器)           │
        │  - 问财 (pywencai)                   │
        └───────────────────────────────────────┘
```

### 1.2 模块依赖关系图

**核心依赖关系**:

- `app.py` → 所有UI模块 → AI分析师 → 数据获取 → 网络优化
- `portfolio_manager.py` → `portfolio_db.py` + `ai_agents.py` + `stock_data.py`
- `portfolio_scheduler.py` → `portfolio_manager.py` + `notification_service.py`
- `ai_agents.py` → `deepseek_client.py` + 各类数据获取器
- `stock_data.py` → `data_source_manager.py` + `network_optimizer.py`
- `data_source_manager.py` → `tushare` + `akshare`
- `network_optimizer.py` → `requests` + `akshare`

### 1.3 快速开始指南

#### 安装依赖

```bash
pip install -r requirements.txt
```

#### 配置环境变量

创建 `.env` 文件：

```env
# Tushare Token（必需，用于A股数据）
TUSHARE_TOKEN=your_tushare_token_here

# DeepSeek API Key（必需，用于AI分析）
DEEPSEEK_API_KEY=your_deepseek_api_key_here
DEEPSEEK_BASE_URL=https://api.deepseek.com

# 邮件通知配置（可选）
SMTP_SERVER=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your_email@gmail.com
SMTP_PASSWORD=your_app_password
SMTP_FROM_EMAIL=your_email@gmail.com
SMTP_TO_EMAIL=recipient@gmail.com

# Webhook通知配置（可选）
WEBHOOK_URL=https://your.webhook.url
WEBHOOK_KEYWORD=股票分析
```

#### 基础使用示例

```python
# 1. 数据获取
from data_source_manager import data_source_manager

# 获取股票历史数据
df = data_source_manager.get_stock_hist_data('002230', start_date='20240101')

# 获取股票基本信息
info = data_source_manager.get_stock_basic_info('002230')

# 2. AI分析
from ai_agents import StockAnalysisAgents
from stock_data import StockDataFetcher

agents = StockAnalysisAgents()
fetcher = StockDataFetcher()

# 获取数据
stock_info = fetcher.get_stock_info('002230')
stock_data = fetcher.get_stock_data('002230', '1y')
indicators = fetcher.calculate_technical_indicators(stock_data)

# 调用技术分析师
result = agents.technical_analyst_agent(stock_info, stock_data, indicators)
print(result['analysis'])

# 3. 持仓管理
from portfolio_manager import portfolio_manager

# 添加持仓股票
success, msg, stock_id = portfolio_manager.add_stock(
    code='002230',
    name='科大讯飞',
    cost_price=55.05,
    quantity=1000
)

# 批量分析持仓
results = portfolio_manager.batch_analyze_portfolio(mode='sequential')
```

### 1.4 环境配置要求

**Python版本**: >= 3.8

**主要依赖**:
- streamlit >= 1.28.0
- pandas >= 1.5.0
- numpy >= 1.24.0
- tushare >= 1.2.89
- akshare >= 1.11.0
- pywencai >= 0.7.0
- openai >= 1.0.0 (用于DeepSeek API)
- schedule >= 1.2.0
- requests >= 2.31.0
- yfinance >= 0.2.28
- ta >= 0.11.0 (技术指标库)

**数据库**: SQLite 3 (无需额外安装)

**网络要求**:
- Tushare: 需要直连访问 (不使用代理)
- Akshare: 可能需要代理 (根据网络环境)
- DeepSeek API: 需要访问国际网络

---

## 2. 统一数据获取模块 (DataSourceManager)

### 2.1 模块简介与设计理念

**文件**: `data_source_manager.py`  
**核心类**: `DataSourceManager`  
**设计目标**: 提供统一的数据获取接口，自动在 Tushare 和 Akshare 之间切换，提高数据获取的可靠性和成功率。

**设计原则**:
1. **优先级策略**: Tushare 优先 (数据质量高、直连快速)，失败时自动切换到 Akshare
2. **无缝切换**: 对上层调用者透明，自动处理数据格式转换
3. **错误容错**: 捕获并记录错误，提供降级方案
4. **数据标准化**: 统一输出格式，便于上层处理

**全局实例**:

```python
from data_source_manager import data_source_manager  # 单例模式
```

### 2.2 初始化与环境配置

#### 构造函数

```python
def __init__(self):
    """
    初始化数据源管理器
    
    自动读取环境变量 TUSHARE_TOKEN 并初始化 Tushare API
    如果 Token 不存在或初始化失败，则标记 tushare_available = False
    """
```

**环境变量**:
- `TUSHARE_TOKEN`: Tushare 的 API Token (必需，否则只能使用 Akshare)

**初始化逻辑**:
1. 读取 `TUSHARE_TOKEN` 环境变量
2. 尝试初始化 Tushare Pro API
3. 设置 `tushare_available` 标志
4. 如果失败，打印警告并标记为不可用

**示例**:

```python
# 在 .env 文件中配置
TUSHARE_TOKEN=your_token_here

# 代码中使用
from data_source_manager import data_source_manager

# 检查 Tushare 是否可用
if data_source_manager.tushare_available:
    print("✓ Tushare 数据源可用")
else:
    print("⚠ Tushare 数据源不可用，将使用 Akshare")
```

### 2.3 核心方法详解

#### 2.3.1 股票行情数据

##### 方法: `get_stock_hist_data(symbol, start_date=None, end_date=None, adjust='qfq')`

获取股票历史行情数据（K线数据）。

**参数**:
- `symbol` (str): 股票代码，6位数字，如 "002230"
- `start_date` (str, optional): 开始日期，格式 "YYYYMMDD" 或 "YYYY-MM-DD"，默认为一年前
- `end_date` (str, optional): 结束日期，格式同上，默认为今天
- `adjust` (str, optional): 复权类型
  - `'qfq'`: 前复权 (默认)
  - `'hfq'`: 后复权
  - `''`: 不复权

**返回值**: `pandas.DataFrame`

返回的DataFrame包含以下列：
- `date` (datetime): 交易日期
- `open` (float): 开盘价
- `high` (float): 最高价
- `low` (float): 最低价
- `close` (float): 收盘价
- `volume` (float): 成交量
- `amount` (float): 成交额

**调用流程**:
1. 优先使用 Tushare (直连，不使用代理)
2. 如果 Tushare 失败或不可用，切换到 Akshare
3. 标准化列名和日期格式
4. 按日期排序

**示例**:

```python
# 获取最近一年的数据
df = data_source_manager.get_stock_hist_data('002230')

# 获取指定日期范围的数据
df = data_source_manager.get_stock_hist_data(
    '002230',
    start_date='20240101',
    end_date='20241031',
    adjust='qfq'
)

# 检查数据
print(df.head())
print(f"数据行数: {len(df)}")
```

**注意事项**:
- 股票代码必须是6位数字，不需要后缀（如 .SH/.SZ）
- 日期格式支持 "YYYYMMDD" 和 "YYYY-MM-DD" 两种
- Tushare 使用直连，不受代理影响
- Akshare 可能需要网络优化器支持

##### 方法: `get_stock_basic_info(symbol)`

获取股票基本信息（名称、行业、市值等）。

**参数**:
- `symbol` (str): 股票代码，6位数字

**返回值**: `dict`

返回字典包含以下字段：
- `symbol` (str): 股票代码
- `name` (str): 股票名称
- `industry` (str): 所属行业
- `market` (str): 所属市场（'主板'/'创业板'/'科创板'等）
- `list_date` (str): 上市日期
- `is_hs` (bool): 是否为沪深股通标的
- `total_mv` (float): 总市值（万元）
- `circ_mv` (float): 流通市值（万元）

**示例**:

```python
info = data_source_manager.get_stock_basic_info('002230')
print(f"股票名称: {info['name']}")
print(f"所属行业: {info['industry']}")
print(f"总市值: {info['total_mv']/10000:.2f}亿")
```

##### 方法: `get_realtime_quotes(symbol)`

获取股票实时行情（当前价格、涨跌幅等）。

**参数**:
- `symbol` (str): 股票代码，6位数字

**返回值**: `dict`

返回字典包含以下字段：
- `symbol` (str): 股票代码
- `name` (str): 股票名称
- `current_price` (float): 最新价
- `open` (float): 今开
- `pre_close` (float): 昨收
- `high` (float): 最高
- `low` (float): 最低
- `volume` (float): 成交量
- `amount` (float): 成交额
- `change` (float): 涨跌额
- `change_percent` (float): 涨跌幅(%)
- `turnover_rate` (float): 换手率(%)
- `amplitude` (float): 振幅(%)

**示例**:

```python
quotes = data_source_manager.get_realtime_quotes('002230')
print(f"最新价: {quotes['current_price']}")
print(f"涨跌幅: {quotes['change_percent']}%")
print(f"换手率: {quotes['turnover_rate']}%")
```

**注意事项**:
- 盘中数据实时更新，盘后为收盘数据
- 如果在非交易时间调用，返回最近一个交易日的收盘数据

#### 2.3.2 财务数据

##### 方法: `get_financial_data(symbol, report_type='income')`

获取股票财务数据（利润表、资产负债表、现金流量表）。

**参数**:
- `symbol` (str): 股票代码，6位数字
- `report_type` (str, optional): 报表类型
  - `'income'`: 利润表 (默认)
  - `'balance'`: 资产负债表
  - `'cashflow'`: 现金流量表

**返回值**: `pandas.DataFrame`

**利润表主要字段**:
- `end_date`: 报告期
- `revenue`: 营业收入
- `operate_profit`: 营业利润
- `total_profit`: 利润总额
- `n_income`: 净利润
- `n_income_attr_p`: 归属母公司净利润
- `diluted_eps`: 稀释每股收益
- `basic_eps`: 基本每股收益

**资产负债表主要字段**:
- `end_date`: 报告期
- `total_assets`: 资产总计
- `total_cur_assets`: 流动资产合计
- `total_liab`: 负债合计
- `total_cur_liab`: 流动负债合计
- `total_hldr_eqy_exc_min_int`: 股东权益合计

**现金流量表主要字段**:
- `end_date`: 报告期
- `n_cashflow_act`: 经营活动现金流量净额
- `n_cashflow_inv_act`: 投资活动现金流量净额
- `n_cashflow_fnc_act`: 融资活动现金流量净额
- `c_cash_equ_end_period`: 期末现金及现金等价物余额

**示例**:

```python
# 获取利润表
income_df = data_source_manager.get_financial_data('002230', 'income')
print("最近4期净利润:")
print(income_df[['end_date', 'n_income']].head(4))

# 获取资产负债表
balance_df = data_source_manager.get_financial_data('002230', 'balance')
print(f"最新资产负债率: {balance_df.iloc[0]['total_liab'] / balance_df.iloc[0]['total_assets'] * 100:.2f}%")

# 获取现金流量表
cashflow_df = data_source_manager.get_financial_data('002230', 'cashflow')
print("最近4期经营现金流:")
print(cashflow_df[['end_date', 'n_cashflow_act']].head(4))
```

#### 2.3.3 资金数据

##### 方法: `get_margin_trading_data(symbol, trade_date=None)`

获取融资融券数据。

**参数**:
- `symbol` (str): 股票代码，6位数字
- `trade_date` (str, optional): 交易日期，格式 "YYYYMMDD"，默认为最近交易日

**返回值**: `dict`

返回字典包含：
- `data_success` (bool): 数据获取是否成功
- `trade_date` (str): 交易日期
- `rzye` (float): 融资余额（元）
- `rqye` (float): 融券余额（元）
- `rzmre` (float): 融资买入额（元）
- `rzche` (float): 融资偿还额（元）
- `rqmcl` (float): 融券卖出量（股）
- `rqchl` (float): 融券偿还量（股）
- `rzrqye` (float): 融资融券余额（元）
- `df_history` (DataFrame): 历史数据（最近30天）

**示例**:

```python
margin_data = data_source_manager.get_margin_trading_data('002230')

if margin_data['data_success']:
    print(f"融资余额: {margin_data['rzye']/100000000:.2f}亿")
    print(f"融券余额: {margin_data['rqye']/100000000:.2f}亿")
    print(f"融资融券余额: {margin_data['rzrqye']/100000000:.2f}亿")
    
    # 查看历史趋势
    print("\n最近10天融资余额:")
    print(margin_data['df_history'][['trade_date', 'rzye']].head(10))
```

##### 方法: `get_hsgt_fund_flow_data(symbol, trade_date=None)`

获取沪深港通资金流向数据。

**参数**:
- `symbol` (str): 股票代码，6位数字
- `trade_date` (str, optional): 交易日期，格式 "YYYYMMDD"

**返回值**: `dict`

返回字典包含：
- `data_success` (bool): 数据获取是否成功
- `trade_date` (str): 交易日期
- `ggt_ss` (float): 港股通（沪）当日成交净买入（亿元）
- `ggt_sz` (float): 港股通（深）当日成交净买入（亿元）
- `hgt` (float): 沪股通当日成交净买入（亿元）
- `sgt` (float): 深股通当日成交净买入（亿元）
- `north_money` (float): 北向资金合计（亿元）
- `south_money` (float): 南向资金合计（亿元）

**示例**:

```python
hsgt_data = data_source_manager.get_hsgt_fund_flow_data('002230')

if hsgt_data['data_success']:
    print(f"沪股通净买入: {hsgt_data['hgt']:.2f}亿")
    print(f"深股通净买入: {hsgt_data['sgt']:.2f}亿")
    print(f"北向资金合计: {hsgt_data['north_money']:.2f}亿")
```

#### 2.3.4 市场数据

##### 方法: `get_market_index_data(index_code='000001.SH', trade_date=None)`

获取市场指数数据。

**参数**:
- `index_code` (str, optional): 指数代码，默认为 "000001.SH" (上证指数)
  - '000001.SH': 上证指数
  - '399001.SZ': 深证成指
  - '399006.SZ': 创业板指
  - '000300.SH': 沪深300
- `trade_date` (str, optional): 交易日期，格式 "YYYYMMDD"

**返回值**: `dict`

返回字典包含指数的实时行情数据。

**示例**:

```python
# 获取上证指数
sh_index = data_source_manager.get_market_index_data('000001.SH')
print(f"上证指数: {sh_index['close']}, 涨跌幅: {sh_index['pct_chg']}%")

# 获取创业板指
cyb_index = data_source_manager.get_market_index_data('399006.SZ')
print(f"创业板指: {cyb_index['close']}, 涨跌幅: {cyb_index['pct_chg']}%")
```

##### 方法: `get_concept_data()`

获取概念板块数据。

**参数**: 无

**返回值**: `pandas.DataFrame`

返回的DataFrame包含：
- `code`: 概念代码
- `name`: 概念名称
- `count`: 成份股数量

**示例**:

```python
concept_df = data_source_manager.get_concept_data()
print(f"概念板块总数: {len(concept_df)}")
print(concept_df.head(10))
```

##### 方法: `get_industry_data()`

获取行业板块数据。

**参数**: 无

**返回值**: `pandas.DataFrame`

返回的DataFrame包含：
- `code`: 行业代码
- `name`: 行业名称
- `count`: 成份股数量

**示例**:

```python
industry_df = data_source_manager.get_industry_data()
print(f"行业板块总数: {len(industry_df)}")
print(industry_df.head(10))
```

##### 方法: `get_longhubang_daily_stats(trade_date=None)`

获取龙虎榜每日统计数据。

**参数**:
- `trade_date` (str, optional): 交易日期，格式 "YYYYMMDD"，默认为最近交易日

**返回值**: `pandas.DataFrame`

返回的DataFrame包含上榜股票的统计信息。

**示例**:

```python
lhb_stats = data_source_manager.get_longhubang_daily_stats('20241031')
print(f"今日上榜股票数: {len(lhb_stats)}")
print(lhb_stats.head())
```

##### 方法: `get_longhubang_institution_details(trade_date=None, ts_code=None)`

获取龙虎榜机构席位明细。

**参数**:
- `trade_date` (str, optional): 交易日期，格式 "YYYYMMDD"
- `ts_code` (str, optional): 股票代码（带后缀）

**返回值**: `pandas.DataFrame`

**示例**:

```python
# 获取特定股票的机构席位
inst_details = data_source_manager.get_longhubang_institution_details(
    trade_date='20241031',
    ts_code='002230.SZ'
)
print(inst_details)
```

##### 方法: `get_longhubang_comprehensive_data(trade_date=None)`

获取龙虎榜综合数据（统计+明细）。

**参数**:
- `trade_date` (str, optional): 交易日期，格式 "YYYYMMDD"

**返回值**: `dict`

返回字典包含：
- `stats`: 统计数据 (DataFrame)
- `details`: 明细数据 (DataFrame)
- `trade_date`: 交易日期

**示例**:

```python
lhb_data = data_source_manager.get_longhubang_comprehensive_data('20241031')
print(f"上榜股票数: {len(lhb_data['stats'])}")
print(f"席位明细数: {len(lhb_data['details'])}")
```

#### 2.3.5 研报与公告

##### 方法: `get_research_reports_data(symbol: str, days: int = 90) -> Dict`

获取研究报告数据（机构研报、评级）。

**参数**:
- `symbol` (str): 股票代码，6位数字
- `days` (int, optional): 查询天数，默认90天

**返回值**: `dict`

返回字典包含：
- `data_success` (bool): 数据获取是否成功
- `symbol` (str): 股票代码
- `report_count` (int): 研报总数
- `rating_changes` (list): 评级变化列表
- `latest_reports` (list): 最新研报列表
- `analysis_summary` (dict): 分析摘要
  - `avg_rating`: 平均评级
  - `buy_ratio`: 买入建议比例
  - `neutral_ratio`: 中性建议比例
  - `sell_ratio`: 卖出建议比例

**示例**:

```python
reports = data_source_manager.get_research_reports_data('002230', days=90)

if reports['data_success']:
    print(f"研报数量: {reports['report_count']}")
    print(f"平均评级: {reports['analysis_summary']['avg_rating']}")
    print(f"买入比例: {reports['analysis_summary']['buy_ratio']}%")
    
    print("\n最新研报:")
    for report in reports['latest_reports'][:5]:
        print(f"- {report['date']}: {report['title']} ({report['org']})")
```

#### 2.3.6 辅助方法

##### 方法: `get_turnover_rate_data(symbol, trade_date=None)`

获取换手率数据。

**参数**:
- `symbol` (str): 股票代码，6位数字
- `trade_date` (str, optional): 交易日期，格式 "YYYYMMDD"

**返回值**: `dict`

返回字典包含：
- `data_success` (bool): 数据获取是否成功
- `turnover_rate` (float): 换手率(%)
- `turnover_rate_f` (float): 自由流通换手率(%)
- `volume_ratio` (float): 量比

**示例**:

```python
turnover_data = data_source_manager.get_turnover_rate_data('002230')
print(f"换手率: {turnover_data['turnover_rate']}%")
print(f"量比: {turnover_data['volume_ratio']}")
```

##### 方法: `is_margin_trading_stock(symbol)`

判断股票是否为融资融券标的。

**参数**:
- `symbol` (str): 股票代码，6位数字

**返回值**: `bool`

**示例**:

```python
if data_source_manager.is_margin_trading_stock('002230'):
    print("该股票是融资融券标的")
else:
    print("该股票不是融资融券标的")
```

##### 方法: `get_tushare_data(interface_name, **kwargs)`

通用的 Tushare 数据获取接口。

**参数**:
- `interface_name` (str): Tushare 接口名称（如 'daily', 'daily_basic'等）
- `**kwargs`: 接口所需的参数

**返回值**: `pandas.DataFrame` 或 `None`

**示例**:

```python
# 调用 daily_basic 接口
daily_basic = data_source_manager.get_tushare_data(
    'daily_basic',
    ts_code='002230.SZ',
    trade_date='20241031'
)
print(daily_basic)

# 调用 stock_basic 接口
stock_basic = data_source_manager.get_tushare_data(
    'stock_basic',
    list_status='L'
)
print(f"A股上市公司数: {len(stock_basic)}")
```

### 2.4 数据源自动切换机制

**切换策略**:

1. **Tushare 优先策略**:
   - 所有方法首先尝试使用 Tushare API
   - Tushare 使用直连模式（不使用代理），速度快、稳定性高
   - 检查 `tushare_available` 标志决定是否尝试

2. **自动降级到 Akshare**:
   - 当 Tushare 不可用或调用失败时
   - 自动切换到 Akshare 作为备用数据源
   - Akshare 可能需要网络优化器支持（代理、重试）

3. **错误处理**:
   - 捕获所有异常并记录日志
   - 返回空数据或错误标志，不中断程序
   - 提供错误信息供上层处理

**切换流程图** (文字描述):

```
开始
  │
  ▼
检查 tushare_available
  │
  ├─ True ──────────────┐
  │                     │
  ├─ False ────┐        │
  │            │        │
  ▼            │        ▼
使用 Akshare   │    尝试 Tushare
  │            │        │
  │            │        ├─ 成功 ──> 标准化数据 ──> 返回
  │            │        │
  │            │        ├─ 失败 ──┐
  │            │        │         │
  │            ▼        ▼         │
  │          记录错误   记录错误   │
  │            │        │         │
  │            ▼        │         │
  │          返回       │         │
  │                     ▼         │
  └─────────────────> 使用 Akshare
                        │
                        ├─ 成功 ──> 标准化数据 ──> 返回
                        │
                        ├─ 失败 ──> 记录错误 ──> 返回空/错误
                        │
                        ▼
                      结束
```

### 2.5 调用示例与最佳实践

#### 完整分析流程示例

```python
from data_source_manager import data_source_manager
import pandas as pd

def comprehensive_stock_analysis(symbol):
    """
    股票综合数据获取示例
    
    Args:
        symbol: 股票代码（6位）
    
    Returns:
        dict: 包含所有数据的字典
    """
    results = {}
    
    # 1. 基本信息
    print(f"[1/7] 获取基本信息...")
    results['basic_info'] = data_source_manager.get_stock_basic_info(symbol)
    print(f"    ✓ 股票名称: {results['basic_info']['name']}")
    
    # 2. 实时行情
    print(f"[2/7] 获取实时行情...")
    results['realtime'] = data_source_manager.get_realtime_quotes(symbol)
    print(f"    ✓ 最新价: {results['realtime']['current_price']}, 涨跌幅: {results['realtime']['change_percent']}%")
    
    # 3. 历史数据（最近一年）
    print(f"[3/7] 获取历史数据...")
    end_date = pd.Timestamp.now().strftime('%Y%m%d')
    start_date = (pd.Timestamp.now() - pd.DateOffset(years=1)).strftime('%Y%m%d')
    results['hist_data'] = data_source_manager.get_stock_hist_data(
        symbol, 
        start_date=start_date, 
        end_date=end_date
    )
    print(f"    ✓ 数据行数: {len(results['hist_data'])}")
    
    # 4. 财务数据
    print(f"[4/7] 获取财务数据...")
    results['income'] = data_source_manager.get_financial_data(symbol, 'income')
    results['balance'] = data_source_manager.get_financial_data(symbol, 'balance')
    results['cashflow'] = data_source_manager.get_financial_data(symbol, 'cashflow')
    print(f"    ✓ 利润表: {len(results['income'])}期")
    print(f"    ✓ 资产负债表: {len(results['balance'])}期")
    print(f"    ✓ 现金流量表: {len(results['cashflow'])}期")
    
    # 5. 融资融券
    print(f"[5/7] 获取融资融券数据...")
    results['margin'] = data_source_manager.get_margin_trading_data(symbol)
    if results['margin']['data_success']:
        print(f"    ✓ 融资余额: {results['margin']['rzye']/100000000:.2f}亿")
    else:
        print(f"    ⚠ 融资融券数据获取失败")
    
    # 6. 沪深港通
    print(f"[6/7] 获取沪深港通数据...")
    results['hsgt'] = data_source_manager.get_hsgt_fund_flow_data(symbol)
    if results['hsgt']['data_success']:
        print(f"    ✓ 北向资金: {results['hsgt']['north_money']:.2f}亿")
    else:
        print(f"    ⚠ 沪深港通数据获取失败")
    
    # 7. 研究报告
    print(f"[7/7] 获取研究报告...")
    results['reports'] = data_source_manager.get_research_reports_data(symbol, days=90)
    if results['reports']['data_success']:
        print(f"    ✓ 研报数量: {results['reports']['report_count']}")
    else:
        print(f"    ⚠ 研究报告数据获取失败")
    
    print("\n✓ 数据获取完成！")
    return results


# 使用示例
if __name__ == '__main__':
    data = comprehensive_stock_analysis('002230')
    
    # 访问数据
    print(f"\n=== 数据摘要 ===")
    print(f"股票名称: {data['basic_info']['name']}")
    print(f"当前价格: {data['realtime']['current_price']}")
    print(f"所属行业: {data['basic_info']['industry']}")
    print(f"历史数据: {len(data['hist_data'])}条")
```

#### 最佳实践

**1. 错误处理**:

```python
# 总是检查返回值
data = data_source_manager.get_stock_hist_data('002230')

if data is None or data.empty:
    print("数据获取失败")
else:
    print(f"获取到 {len(data)} 条数据")

# 对于字典类型的返回值，检查 data_success 标志
margin_data = data_source_manager.get_margin_trading_data('002230')

if margin_data.get('data_success', False):
    # 使用数据
    print(f"融资余额: {margin_data['rzye']}")
else:
    print("融资融券数据不可用")
```

**2. 日期格式处理**:

```python
from datetime import datetime, timedelta

# 推荐使用 YYYYMMDD 格式
today = datetime.now().strftime('%Y%m%d')
one_year_ago = (datetime.now() - timedelta(days=365)).strftime('%Y%m%d')

df = data_source_manager.get_stock_hist_data(
    '002230',
    start_date=one_year_ago,
    end_date=today
)
```

**3. 批量获取数据**:

```python
symbols = ['002230', '600519', '000001']
results = {}

for symbol in symbols:
    try:
        results[symbol] = data_source_manager.get_stock_hist_data(symbol)
        print(f"✓ {symbol}: {len(results[symbol])} 条数据")
    except Exception as e:
        print(f"✗ {symbol}: 获取失败 - {e}")
        results[symbol] = None
```

**4. 数据缓存**:

```python
import pickle
from pathlib import Path

def get_cached_data(symbol, cache_hours=1):
    """
    带缓存的数据获取
    
    Args:
        symbol: 股票代码
        cache_hours: 缓存有效期（小时）
    
    Returns:
        DataFrame: 历史数据
    """
    cache_file = Path(f"cache/{symbol}.pkl")
    
    # 检查缓存
    if cache_file.exists():
        cache_time = datetime.fromtimestamp(cache_file.stat().st_mtime)
        if datetime.now() - cache_time < timedelta(hours=cache_hours):
            print(f"从缓存读取 {symbol}")
            with open(cache_file, 'rb') as f:
                return pickle.load(f)
    
    # 获取新数据
    print(f"从网络获取 {symbol}")
    data = data_source_manager.get_stock_hist_data(symbol)
    
    # 保存缓存
    cache_file.parent.mkdir(exist_ok=True)
    with open(cache_file, 'wb') as f:
        pickle.dump(data, f)
    
    return data
```

### 2.6 错误处理与注意事项

#### 常见错误

**1. Tushare Token 未配置**:

```
错误信息: "未配置Tushare Token，将仅使用Akshare数据源"
解决方案: 在 .env 文件中设置 TUSHARE_TOKEN
```

**2. 股票代码格式错误**:

```python
# 错误示例
data = data_source_manager.get_stock_hist_data('002230.SZ')  # 带后缀

# 正确示例
data = data_source_manager.get_stock_hist_data('002230')  # 不带后缀
```

**3. 日期格式错误**:

```python
# 错误示例
data = data_source_manager.get_stock_hist_data('002230', start_date='2024/01/01')

# 正确示例
data = data_source_manager.get_stock_hist_data('002230', start_date='20240101')
# 或
data = data_source_manager.get_stock_hist_data('002230', start_date='2024-01-01')
```

**4. 网络连接问题**:

```
错误信息: "网络连接超时" 或 "数据获取失败"
解决方案: 
  - 检查网络连接
  - 配置代理（通过 network_optimizer）
  - 重试机制会自动处理
```

#### 注意事项

1. **数据延迟**:
   - Tushare 数据有一定延迟（通常几分钟到几小时）
   - 实时行情数据在盘后为收盘数据
   - 财务数据更新频率为季度

2. **API 限制**:
   - Tushare 有调用频率限制（根据账户等级）
   - 建议使用缓存机制减少重复调用
   - 批量获取时建议添加延时

3. **数据质量**:
   - 部分数据可能缺失或不准确
   - 建议关键数据进行交叉验证
   - 停牌股票可能无法获取实时数据

4. **性能优化**:
   - 批量获取时使用并发（但注意频率限制）
   - 缓存常用数据
   - 避免在短时间内重复获取相同数据

5. **数据标准化**:
   - 不同数据源的数据格式已自动标准化
   - 但数值可能略有差异
   - 建议以 Tushare 数据为准（当可用时）

---

## 3. 网络优化模块 (NetworkOptimizer)

### 3.1 模块简介与应用场景

**文件**: `network_optimizer.py`  
**核心类**: `NetworkOptimizer`  
**设计目标**: 解决 Akshare 数据获取时的网络连接问题，提供代理池管理、请求重试、延迟控制等功能。

**应用场景**:
1. **网络受限环境**: Akshare 某些接口需要访问国外网站，可能被墙
2. **频繁请求**: 需要重试机制和延迟控制避免被封
3. **多代理管理**: 支持静态代理和动态代理的管理
4. **ETF数据获取**: 封装了专门的 ETF 数据获取方法

**核心特性**:
- 支持静态代理和动态代理
- 代理池管理和优先级配置
- 代理测试和自动切换
- 请求重试机制（指数退避）
- 配置文件持久化
- 与 Akshare 深度集成

**全局实例**:

```python
from network_optimizer import network_optimizer  # 单例模式
```

### 3.2 代理配置文件格式

**配置文件**: `proxy_config.json`

**文件结构**:

```json
{
  "proxy_priority": [
    {
      "name": "直连模式",
      "proxy": null,
      "enabled": true,
      "priority": 1,
      "description": "不使用代理，直接连接"
    },
    {
      "name": "我的代理1",
      "proxy": "http://127.0.0.1:7890",
      "enabled": true,
      "priority": 2,
      "description": "本地代理"
    },
    {
      "name": "动态IP代理",
      "type": "dynamic",
      "api_url": "http://api.proxy.com/get",
      "username": "user",
      "password": "pass",
      "enabled": true,
      "priority": 3,
      "description": "动态IP代理，自动获取最新代理服务器"
    }
  ],
  "use_proxy": false
}
```

**字段说明**:

- `proxy_priority`: 代理列表（按优先级排序）
  - `name` (str): 代理名称
  - `proxy` (str|null): 代理地址（格式: `http://host:port` 或 `http://user:pass@host:port`）
  - `type` (str, optional): 代理类型（`"static"` 或 `"dynamic"`）
  - `api_url` (str, optional): 动态代理 API 地址（仅 type="dynamic" 时需要）
  - `username` (str, optional): 动态代理用户名
  - `password` (str, optional): 动态代理密码
  - `enabled` (bool): 是否启用
  - `priority` (int): 优先级（数字越小优先级越高）
  - `description` (str): 描述信息

- `use_proxy` (bool): 全局代理开关

### 3.3 核心功能详解

#### 3.3.1 静态代理管理

##### 方法: `add_proxy(name, proxy_config, priority=999, enabled=True, description="")`

添加静态代理到代理池。

**参数**:
- `name` (str): 代理名称（唯一标识）
- `proxy_config` (dict): 代理配置
  - `proxy` (str): 代理地址，格式: `http://host:port`
  - 或完整配置字典
- `priority` (int, optional): 优先级，默认999
- `enabled` (bool, optional): 是否启用，默认True
- `description` (str, optional): 描述信息

**返回值**: `bool` - 是否添加成功

**示例**:

```python
# 添加简单代理
success = network_optimizer.add_proxy(
    name="本地代理",
    proxy_config={"proxy": "http://127.0.0.1:7890"},
    priority=2,
    description="本地clash代理"
)

# 添加带认证的代理
success = network_optimizer.add_proxy(
    name="VPN代理",
    proxy_config={"proxy": "http://user:pass@proxy.example.com:8080"},
    priority=3,
    description="公司VPN代理"
)

if success:
    print("代理添加成功")
else:
    print("代理添加失败（可能已存在）")
```

##### 方法: `remove_proxy(name)`

从代理池中删除指定代理。

**参数**:
- `name` (str): 代理名称

**返回值**: `bool` - 是否删除成功

**示例**:

```python
success = network_optimizer.remove_proxy("本地代理")
if success:
    print("代理删除成功")
```

##### 方法: `update_proxy_priority(name, priority)`

更新代理的优先级。

**参数**:
- `name` (str): 代理名称
- `priority` (int): 新的优先级

**返回值**: `bool` - 是否更新成功

**示例**:

```python
# 提高代理优先级
network_optimizer.update_proxy_priority("本地代理", priority=1)
```

##### 方法: `toggle_proxy(name, enabled)`

启用或禁用指定代理。

**参数**:
- `name` (str): 代理名称
- `enabled` (bool): True=启用, False=禁用

**返回值**: `bool` - 是否操作成功

**示例**:

```python
# 禁用代理
network_optimizer.toggle_proxy("本地代理", False)

# 启用代理
network_optimizer.toggle_proxy("本地代理", True)
```

##### 方法: `get_proxy_list()`

获取所有代理列表。

**参数**: 无

**返回值**: `list` - 代理配置列表

**示例**:

```python
proxies = network_optimizer.get_proxy_list()

print("代理列表:")
for p in proxies:
    status = "启用" if p['enabled'] else "禁用"
    print(f"- {p['name']} (优先级: {p['priority']}, 状态: {status})")
    print(f"  {p['description']}")
```

#### 3.3.2 动态代理获取与管理

##### 方法: `add_dynamic_proxy_source(name, api_url, username="", password="", priority=10, enabled=True, description="", api_key=None)`

添加动态代理源。

**参数**:
- `name` (str): 代理源名称
- `api_url` (str): 动态代理 API 地址
- `username` (str, optional): 用户名
- `password` (str, optional): 密码
- `priority` (int, optional): 优先级，默认10
- `enabled` (bool, optional): 是否启用，默认True
- `description` (str, optional): 描述信息
- `api_key` (str, optional): API密钥

**返回值**: `bool` - 是否添加成功

**示例**:

```python
# 添加动态代理源
success = network_optimizer.add_dynamic_proxy_source(
    name="阿布云动态代理",
    api_url="http://http-api.abuyun.com/switch-ip",
    username="H12345678",
    password="0123456789ABCDEF",
    priority=2,
    description="阿布云HTTP代理"
)

if success:
    print("动态代理源添加成功")
```

##### 方法: `get_dynamic_proxy_from_source(source_name)`

从指定动态代理源获取代理IP。

**参数**:
- `source_name` (str): 代理源名称

**返回值**: `dict` - 代理配置或空字典（失败时）

返回字典包含：
- `proxy`: 代理地址
- `ip`: IP地址
- `port`: 端口
- `expire_time`: 过期时间（如果有）

**示例**:

```python
proxy_info = network_optimizer.get_dynamic_proxy_from_source("阿布云动态代理")

if proxy_info:
    print(f"获取到代理: {proxy_info['proxy']}")
    print(f"IP: {proxy_info.get('ip')}, 端口: {proxy_info.get('port')}")
else:
    print("获取动态代理失败")
```

##### 方法: `get_dynamic_proxy(api_url, username="", password="", api_key="")`

通用的动态代理获取方法。

**参数**:
- `api_url` (str): 动态代理 API 地址
- `username` (str, optional): 用户名
- `password` (str, optional): 密码
- `api_key` (str, optional): API密钥

**返回值**: `dict` - 代理配置

**示例**:

```python
proxy = network_optimizer.get_dynamic_proxy(
    api_url="http://api.proxy.com/get?token=xxx",
    api_key="your_api_key"
)

if proxy:
    print(f"代理地址: {proxy['proxy']}")
```

#### 3.3.3 代理测试与验证

##### 方法: `test_proxy(proxy_config)`

测试单个代理是否可用（完整测试）。

**参数**:
- `proxy_config` (dict): 代理配置
  - `proxy` (str): 代理地址

**返回值**: `bool` - 代理是否可用

**测试内容**:
1. 访问百度（测试国内网络）
2. 访问 Google（测试国际网络）
3. 访问 Akshare 数据源

**示例**:

```python
proxy_config = {"proxy": "http://127.0.0.1:7890"}
is_available = network_optimizer.test_proxy(proxy_config)

if is_available:
    print("✓ 代理可用")
else:
    print("✗ 代理不可用")
```

##### 方法: `test_proxy_fast(proxy_config)`

快速测试代理（仅测试连接性）。

**参数**:
- `proxy_config` (dict): 代理配置

**返回值**: `bool` - 代理是否可用

**测试内容**:
- 仅访问百度测试连接性（速度快）

**示例**:

```python
is_available = network_optimizer.test_proxy_fast({"proxy": "http://127.0.0.1:7890"})
```

##### 方法: `test_proxy_list(proxy_list, max_test=20, progress_callback=None)`

批量测试代理列表。

**参数**:
- `proxy_list` (list): 代理地址列表（字符串形式）
- `max_test` (int, optional): 最大测试数量，默认20
- `progress_callback` (callable, optional): 进度回调函数

**返回值**: `dict`

返回字典包含：
- `total`: 总测试数
- `success`: 成功数
- `failed`: 失败数
- `available_proxies`: 可用代理列表
- `failed_proxies`: 不可用代理列表

**示例**:

```python
proxy_list = [
    "http://127.0.0.1:7890",
    "http://proxy1.example.com:8080",
    "http://proxy2.example.com:8080"
]

def show_progress(current, total):
    print(f"测试进度: {current}/{total}")

result = network_optimizer.test_proxy_list(
    proxy_list,
    max_test=10,
    progress_callback=show_progress
)

print(f"测试完成:")
print(f"  总数: {result['total']}")
print(f"  成功: {result['success']}")
print(f"  失败: {result['failed']}")
print(f"  可用代理: {len(result['available_proxies'])}")
```

##### 方法: `parse_proxy_txt_file(file_content)`

解析代理文本文件内容。

**参数**:
- `file_content` (str): 文件内容（每行一个代理）

**返回值**: `list` - 代理地址列表

**支持格式**:
- `host:port`
- `http://host:port`
- `user:pass@host:port`
- `http://user:pass@host:port`

**示例**:

```python
file_content = """
127.0.0.1:7890
http://proxy1.com:8080
user:pass@proxy2.com:3128
"""

proxies = network_optimizer.parse_proxy_txt_file(file_content)
print(f"解析到 {len(proxies)} 个代理")
```

#### 3.3.4 网络请求重试机制

**重试策略**:

1. **指数退避算法**:
   - 第1次重试: 延迟 2秒
   - 第2次重试: 延迟 4秒
   - 第3次重试: 延迟 8秒
   - 最多重试 3 次

2. **代理自动切换**:
   - 每次重试时自动切换到下一个可用代理
   - 按优先级顺序尝试
   - 如果所有代理都失败，最后尝试直连

3. **错误类型判断**:
   - 网络超时: 重试
   - 连接拒绝: 重试
   - HTTP 5xx: 重试
   - HTTP 4xx: 不重试
   - 数据解析错误: 不重试

**内部方法**: `_make_request_with_retry(func, *args, **kwargs)`

该方法封装了重试逻辑，自动应用于所有网络请求。

#### 3.3.5 ETF数据获取封装

##### 方法: `get_etf_spot_data_with_retry()`

获取 ETF 实时行情数据（带重试）。

**参数**: 无

**返回值**: `pandas.DataFrame` - ETF实时行情数据

**示例**:

```python
etf_spot = network_optimizer.get_etf_spot_data_with_retry()

if etf_spot is not None:
    print(f"获取到 {len(etf_spot)} 只 ETF 实时数据")
    print(etf_spot.head())
else:
    print("ETF 实时数据获取失败")
```

##### 方法: `get_etf_hist_data_with_retry(symbol, period="1y", adjust="qfq")`

获取 ETF 历史数据（带重试）。

**参数**:
- `symbol` (str): ETF代码
- `period` (str, optional): 时间周期，默认"1y"
- `adjust` (str, optional): 复权类型，默认"qfq"

**返回值**: `pandas.DataFrame` - ETF历史数据

**示例**:

```python
etf_hist = network_optimizer.get_etf_hist_data_with_retry('510300', period='1y')

if etf_hist is not None:
    print(f"获取到 {len(etf_hist)} 条历史数据")
    print(etf_hist.tail())
else:
    print("ETF 历史数据获取失败")
```

### 3.4 使用流程图

**代理配置和使用流程** (文字描述):

```
启动应用
  │
  ▼
NetworkOptimizer 初始化
  │
  ├─ 加载 proxy_config.json
  │  │
  │  ├─ 文件存在 ──> 读取配置
  │  │
  │  └─ 文件不存在 ──> 创建默认配置
  │
  ├─ 初始化代理池
  │  │
  │  └─ 按优先级排序代理列表
  │
  └─ 配置 requests 会话
     │
     └─ 设置超时、重试等参数

网络请求流程
  │
  ▼
检查 use_proxy 开关
  │
  ├─ False ──> 直连请求 ──> 返回结果
  │
  └─ True ──> 使用代理池
             │
             ▼
          选择首个启用的代理
             │
             ▼
          发送请求
             │
             ├─ 成功 ──> 返回结果
             │
             └─ 失败 ──> 切换下一个代理 ──> 重试
                         │
                         ├─ 成功 ──> 返回结果
                         │
                         └─ 所有代理都失败
                             │
                             └─ 尝试直连 ──> 返回结果/失败
```

### 3.5 配置文件示例 (proxy_config.json)

#### 示例1: 基本配置（直连 + 本地代理）

```json
{
  "proxy_priority": [
    {
      "name": "直连模式",
      "proxy": null,
      "enabled": true,
      "priority": 1,
      "description": "不使用代理，直接连接"
    },
    {
      "name": "本地Clash",
      "proxy": "http://127.0.0.1:7890",
      "enabled": true,
      "priority": 2,
      "description": "本地Clash代理"
    }
  ],
  "use_proxy": false
}
```

#### 示例2: 多代理配置（包含动态代理）

```json
{
  "proxy_priority": [
    {
      "name": "直连模式",
      "proxy": null,
      "enabled": true,
      "priority": 1,
      "description": "优先直连"
    },
    {
      "name": "本地Clash",
      "proxy": "http://127.0.0.1:7890",
      "enabled": true,
      "priority": 2,
      "description": "本地Clash代理"
    },
    {
      "name": "公司VPN",
      "proxy": "http://vpn.company.com:8080",
      "enabled": false,
      "priority": 3,
      "description": "公司VPN代理（需要时启用）"
    },
    {
      "name": "动态IP代理",
      "type": "dynamic",
      "api_url": "http://api.proxy.com/get?token=xxx&count=1",
      "username": "user",
      "password": "pass",
      "enabled": true,
      "priority": 4,
      "description": "动态IP代理池"
    }
  ],
  "use_proxy": true
}
```

#### 示例3: 高级配置（带认证）

```json
{
  "proxy_priority": [
    {
      "name": "直连模式",
      "proxy": null,
      "enabled": false,
      "priority": 99,
      "description": "直连被墙，禁用"
    },
    {
      "name": "付费代理1",
      "proxy": "http://user1:pass1@proxy1.example.com:8080",
      "enabled": true,
      "priority": 1,
      "description": "主代理服务器"
    },
    {
      "name": "付费代理2",
      "proxy": "http://user2:pass2@proxy2.example.com:8080",
      "enabled": true,
      "priority": 2,
      "description": "备用代理服务器"
    }
  ],
  "use_proxy": true
}
```

### 3.6 故障排查指南

#### 问题1: 所有请求都失败

**现象**: 所有网络请求都返回失败

**可能原因**:
1. 网络完全断开
2. 所有代理都不可用
3. 目标网站被墙

**解决步骤**:
```python
# 1. 测试网络连接
is_connected = network_optimizer.test_network_connection()
print(f"网络连接: {is_connected}")

# 2. 查看网络状态
status = network_optimizer.get_network_status()
print(f"代理状态: {status}")

# 3. 测试所有代理
proxies = network_optimizer.get_proxy_list()
for proxy in proxies:
    if proxy['enabled'] and proxy['proxy']:
        is_ok = network_optimizer.test_proxy_fast(proxy)
        print(f"{proxy['name']}: {'✓' if is_ok else '✗'}")

# 4. 尝试禁用代理（直连）
network_optimizer.disable_proxy()
```

#### 问题2: 部分请求失败

**现象**: 某些请求成功，某些请求失败

**可能原因**:
1. 代理稳定性问题
2. 目标网站限流
3. 请求超时

**解决步骤**:
```python
# 1. 启用日志
import logging
logging.basicConfig(level=logging.DEBUG)

# 2. 查看请求统计
status = network_optimizer.get_network_status()
print(f"请求次数: {status['request_count']}")
print(f"成功率: 估算")

# 3. 调整重试参数（内部实现，可通过修改源码调整）
# 可以增加重试次数或延长超时时间
```

#### 问题3: 动态代理获取失败

**现象**: `get_dynamic_proxy_from_source()` 返回空字典

**可能原因**:
1. 动态代理 API 配置错误
2. 账户余额不足
3. API 限流

**解决步骤**:
```python
# 1. 检查动态代理配置
proxies = network_optimizer.get_proxy_list()
dynamic_proxies = [p for p in proxies if p.get('type') == 'dynamic']
print("动态代理配置:")
for p in dynamic_proxies:
    print(f"  - {p['name']}: {p.get('api_url')}")

# 2. 手动测试 API
import requests
api_url = "your_dynamic_proxy_api_url"
try:
    response = requests.get(api_url, timeout=10)
    print(f"API 响应: {response.status_code}")
    print(f"内容: {response.text}")
except Exception as e:
    print(f"API 请求失败: {e}")

# 3. 查看日志输出
# 日志中会显示具体的错误信息
```

#### 问题4: 配置文件损坏

**现象**: `proxy_config.json` 无法读取

**解决步骤**:
```python
import json
import os

# 1. 备份现有配置
if os.path.exists('proxy_config.json'):
    os.rename('proxy_config.json', 'proxy_config.json.bak')

# 2. 创建新配置
default_config = {
    "proxy_priority": [
        {
            "name": "直连模式",
            "proxy": None,
            "enabled": True,
            "priority": 1,
            "description": "不使用代理"
        }
    ],
    "use_proxy": False
}

with open('proxy_config.json', 'w', encoding='utf-8') as f:
    json.dump(default_config, f, ensure_ascii=False, indent=2)

print("已创建新的默认配置文件")
```

#### 常用调试命令

```python
from network_optimizer import network_optimizer

# 查看当前配置
status = network_optimizer.get_network_status()
print(f"代理启用: {status['use_proxy']}")
print(f"代理池大小: {status['proxy_pool_size']}")
print(f"当前代理: {status.get('current_proxy')}")

# 列出所有代理
proxies = network_optimizer.get_proxy_list()
for p in proxies:
    print(f"{p['priority']}. {p['name']}: {p.get('proxy')} ({'启用' if p['enabled'] else '禁用'})")

# 测试网络
print(f"网络连接: {network_optimizer.test_network_connection()}")

# 强制刷新代理
network_optimizer._switch_proxy()
print("已切换到下一个代理")
```

---

*继续下一章节...*

